{"version":3,"file":"material-chips.umd.min.js","sources":["../../node_modules/tslib/tslib.es6.js","../../src/lib/chips/chip.ts","../../src/lib/chips/chip-list.ts","../../src/lib/chips/chip-input.ts","../../src/lib/chips/chips-module.ts"],"sourcesContent":["/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = Object.setPrototypeOf ||\r\n    ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n    function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n\r\nexport function __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = Object.assign || function __assign(t) {\r\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n        s = arguments[i];\r\n        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n    }\r\n    return t;\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e.indexOf(p[i]) < 0)\r\n            t[p[i]] = s[p[i]];\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = y[op[0] & 2 ? \"return\" : op[0] ? \"throw\" : \"next\"]) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [0, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport function __exportStar(m, exports) {\r\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\r\n}\r\n\r\nexport function __values(o) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator], i = 0;\r\n    if (m) return m.call(o);\r\n    return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);  }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { if (o[n]) i[n] = function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; }; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator];\r\n    return m ? m.call(o) : typeof __values === \"function\" ? __values(o) : o[Symbol.iterator]();\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {FocusableOption} from '@angular/cdk/a11y';\nimport {coerceBooleanProperty} from '@angular/cdk/coercion';\nimport {BACKSPACE, DELETE, SPACE} from '@angular/cdk/keycodes';\nimport {\n  Directive,\n  ElementRef,\n  EventEmitter,\n  Input,\n  OnDestroy,\n  Output,\n} from '@angular/core';\nimport {CanColor, CanDisable, mixinColor, mixinDisabled} from '@angular/material/core';\nimport {Subject} from 'rxjs/Subject';\n\n\n/** Represents an event fired on an individual `mat-chip`. */\nexport interface MatChipEvent {\n  /** The chip the event was fired on. */\n  chip: MatChip;\n}\n\n/** Event object emitted by MatChip when selected or deselected. */\nexport class MatChipSelectionChange {\n  constructor(\n    /** Reference to the chip that emitted the event. */\n    public source: MatChip,\n    /** Whether the chip that emitted the event is selected. */\n    public selected: boolean,\n    /** Whether the selection change was a result of a user interaction. */\n    public isUserInput = false) { }\n}\n\n\n// Boilerplate for applying mixins to MatChip.\n/** @docs-private */\nexport class MatChipBase {\n  constructor(public _elementRef: ElementRef) {}\n}\n\nexport const _MatChipMixinBase = mixinColor(mixinDisabled(MatChipBase), 'primary');\n\n\n/**\n * Dummy directive to add CSS class to basic chips.\n * @docs-private\n */\n@Directive({\n  selector: `mat-basic-chip, [mat-basic-chip]`,\n  host: {'class': 'mat-basic-chip'},\n})\nexport class MatBasicChip {\n}\n\n/**\n * Material design styled Chip component. Used inside the MatChipList component.\n */\n@Directive({\n  selector: `mat-basic-chip, [mat-basic-chip], mat-chip, [mat-chip]`,\n  inputs: ['color', 'disabled'],\n  exportAs: 'matChip',\n  host: {\n    'class': 'mat-chip',\n    '[attr.tabindex]': 'disabled ? null : -1',\n    'role': 'option',\n    '[class.mat-chip-selected]': 'selected',\n    '[attr.disabled]': 'disabled || null',\n    '[attr.aria-disabled]': 'disabled.toString()',\n    '[attr.aria-selected]': 'ariaSelected',\n    '(click)': '_handleClick($event)',\n    '(keydown)': '_handleKeydown($event)',\n    '(focus)': '_hasFocus = true',\n    '(blur)': '_blur()',\n  },\n\n})\nexport class MatChip extends _MatChipMixinBase implements FocusableOption, OnDestroy, CanColor,\n    CanDisable {\n\n  protected _value: any;\n\n  protected _selected: boolean = false;\n\n  protected _selectable: boolean = true;\n\n  protected _removable: boolean = true;\n\n  /** Whether the chip has focus. */\n  _hasFocus: boolean = false;\n\n  /** Whether the chip is selected. */\n  @Input()\n  get selected(): boolean {\n    return this._selected;\n  }\n  set selected(value: boolean) {\n    this._selected = coerceBooleanProperty(value);\n    this.selectionChange.emit({\n      source: this,\n      isUserInput: false,\n      selected: value\n    });\n  }\n  /** The value of the chip. Defaults to the content inside <mat-chip> tags. */\n  @Input()\n  get value(): any {\n    return this._value != undefined\n      ? this._value\n      : this._elementRef.nativeElement.textContent;\n  }\n  set value(newValue: any) {\n    this._value = newValue;\n  }\n\n  /**\n   * Whether or not the chips are selectable. When a chip is not selectable,\n   * changes to it's selected state are always ignored.\n   */\n  @Input() get selectable(): boolean {\n    return this._selectable;\n  }\n\n\n  set selectable(value: boolean) {\n    this._selectable = coerceBooleanProperty(value);\n  }\n\n  /**\n   * Determines whether or not the chip displays the remove styling and emits (remove) events.\n   */\n  @Input() get removable(): boolean {\n    return this._removable;\n  }\n\n\n  set removable(value: boolean) {\n    this._removable = coerceBooleanProperty(value);\n  }\n\n  /** Emits when the chip is focused. */\n  _onFocus = new Subject<MatChipEvent>();\n\n  /** Emits when the chip is blured. */\n  _onBlur = new Subject<MatChipEvent>();\n\n  /** Emitted when the chip is selected or deselected. */\n  @Output() selectionChange = new EventEmitter<MatChipSelectionChange>();\n\n  /** Emitted when the chip is destroyed. */\n  @Output() destroyed = new EventEmitter<MatChipEvent>();\n\n  /**\n   * Emitted when the chip is destroyed.\n   * @deprecated Use 'destroyed' instead.\n   */\n  @Output() destroy = this.destroyed;\n\n  /** Emitted when a chip is to be removed. */\n  @Output() removed = new EventEmitter<MatChipEvent>();\n\n  /**\n   * Emitted when a chip is to be removed.\n   * @deprecated Use `removed` instead.\n   */\n  @Output('remove') onRemove = this.removed;\n\n  get ariaSelected(): string | null {\n    return this.selectable ? this.selected.toString() : null;\n  }\n\n  constructor(public _elementRef: ElementRef) {\n    super(_elementRef);\n  }\n\n  ngOnDestroy(): void {\n    this.destroyed.emit({chip: this});\n  }\n\n  /** Selects the chip. */\n  select(): void {\n    this._selected = true;\n    this.selectionChange.emit({\n      source: this,\n      isUserInput: false,\n      selected: true\n    });\n  }\n\n  /** Deselects the chip. */\n  deselect(): void {\n    this._selected = false;\n    this.selectionChange.emit({\n      source: this,\n      isUserInput: false,\n      selected: false\n    });\n  }\n\n  /** Select this chip and emit selected event */\n  selectViaInteraction(): void {\n    this._selected = true;\n    // Emit select event when selected changes.\n    this.selectionChange.emit({\n      source: this,\n      isUserInput: true,\n      selected: true\n    });\n  }\n\n  /** Toggles the current selected state of this chip. */\n  toggleSelected(isUserInput: boolean = false): boolean {\n    this._selected = !this.selected;\n\n    this.selectionChange.emit({\n      source: this,\n      isUserInput,\n      selected: this._selected\n    });\n\n    return this.selected;\n  }\n\n  /** Allows for programmatic focusing of the chip. */\n  focus(): void {\n    this._elementRef.nativeElement.focus();\n    this._onFocus.next({chip: this});\n  }\n\n  /**\n   * Allows for programmatic removal of the chip. Called by the MatChipList when the DELETE or\n   * BACKSPACE keys are pressed.\n   *\n   * Informs any listeners of the removal request. Does not remove the chip from the DOM.\n   */\n  remove(): void {\n    if (this.removable) {\n      this.removed.emit({chip: this});\n    }\n  }\n\n  /** Ensures events fire properly upon click. */\n  _handleClick(event: Event) {\n    // Check disabled\n    if (this.disabled) {\n      return;\n    }\n\n    event.preventDefault();\n    event.stopPropagation();\n\n    this.focus();\n  }\n\n  /** Handle custom key presses. */\n  _handleKeydown(event: KeyboardEvent): void {\n    if (this.disabled) {\n      return;\n    }\n\n    switch (event.keyCode) {\n      case DELETE:\n      case BACKSPACE:\n        // If we are removable, remove the focused chip\n        this.remove();\n        // Always prevent so page navigation does not occur\n        event.preventDefault();\n        break;\n      case SPACE:\n        // If we are selectable, toggle the focused chip\n        if (this.selectable) {\n          this.toggleSelected(true);\n        }\n\n        // Always prevent space from scrolling the page since the list has focus\n        event.preventDefault();\n        break;\n    }\n  }\n\n  _blur(): void {\n    this._hasFocus = false;\n    this._onBlur.next({chip: this});\n  }\n}\n\n\n/**\n * Applies proper (click) support and adds styling for use with the Material Design \"cancel\" icon\n * available at https://material.io/icons/#ic_cancel.\n *\n * Example:\n *\n *     <mat-chip>\n *       <mat-icon matChipRemove>cancel</mat-icon>\n *     </mat-chip>\n *\n * You *may* use a custom icon, but you may need to override the `mat-chip-remove` positioning\n * styles to properly center the icon within the chip.\n */\n@Directive({\n  selector: '[matChipRemove]',\n  host: {\n    'class': 'mat-chip-remove',\n    '(click)': '_handleClick()',\n  }\n})\nexport class MatChipRemove {\n  constructor(protected _parentChip: MatChip) {\n  }\n\n  /** Calls the parent chip's public `remove()` method if applicable. */\n  _handleClick(): void {\n    if (this._parentChip.removable) {\n      this._parentChip.remove();\n    }\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {FocusKeyManager} from '@angular/cdk/a11y';\nimport {Directionality} from '@angular/cdk/bidi';\nimport {coerceBooleanProperty} from '@angular/cdk/coercion';\nimport {SelectionModel} from '@angular/cdk/collections';\nimport {BACKSPACE, LEFT_ARROW, RIGHT_ARROW} from '@angular/cdk/keycodes';\nimport {startWith} from 'rxjs/operators/startWith';\nimport {\n  AfterContentInit,\n  ChangeDetectionStrategy,\n  ChangeDetectorRef,\n  Component,\n  ContentChildren,\n  DoCheck,\n  ElementRef,\n  EventEmitter,\n  Input,\n  OnDestroy,\n  OnInit,\n  Optional,\n  Output,\n  QueryList,\n  Self,\n  ViewEncapsulation,\n} from '@angular/core';\nimport {\n  ControlValueAccessor,\n  FormGroupDirective,\n  NgControl,\n  NgForm\n} from '@angular/forms';\nimport {ErrorStateMatcher, mixinErrorState, CanUpdateErrorState} from '@angular/material/core';\nimport {MatFormFieldControl} from '@angular/material/form-field';\nimport {Observable} from 'rxjs/Observable';\nimport {merge} from 'rxjs/observable/merge';\nimport {Subscription} from 'rxjs/Subscription';\nimport {MatChip, MatChipEvent, MatChipSelectionChange} from './chip';\nimport {MatChipInput} from './chip-input';\n\n// Boilerplate for applying mixins to MatChipList.\n/** @docs-private */\nexport class MatChipListBase {\n  constructor(public _defaultErrorStateMatcher: ErrorStateMatcher,\n              public _parentForm: NgForm,\n              public _parentFormGroup: FormGroupDirective,\n              public ngControl: NgControl) {}\n}\nexport const _MatChipListMixinBase = mixinErrorState(MatChipListBase);\n\n\n// Increasing integer for generating unique ids for chip-list components.\nlet nextUniqueId = 0;\n\n/** Change event object that is emitted when the chip list value has changed. */\nexport class MatChipListChange {\n  constructor(\n    /** Chip list that emitted the event. */\n    public source: MatChipList,\n    /** Value of the chip list when the event was emitted. */\n    public value: any) { }\n}\n\n\n/**\n * A material design chips component (named ChipList for it's similarity to the List component).\n */\n@Component({\n  moduleId: module.id,\n  selector: 'mat-chip-list',\n  template: `<div class=\"mat-chip-list-wrapper\"><ng-content></ng-content></div>`,\n  exportAs: 'matChipList',\n  host: {\n    '[attr.tabindex]': '_tabIndex',\n    '[attr.aria-describedby]': '_ariaDescribedby || null',\n    '[attr.aria-required]': 'required.toString()',\n    '[attr.aria-disabled]': 'disabled.toString()',\n    '[attr.aria-invalid]': 'errorState',\n    '[attr.aria-multiselectable]': 'multiple',\n    '[attr.role]': 'role',\n    '[class.mat-chip-list-disabled]': 'disabled',\n    '[class.mat-chip-list-invalid]': 'errorState',\n    '[class.mat-chip-list-required]': 'required',\n    '[attr.aria-orientation]': 'ariaOrientation',\n    'class': 'mat-chip-list',\n    '(focus)': 'focus()',\n    '(blur)': '_blur()',\n    '(keydown)': '_keydown($event)'\n  },\n  providers: [{provide: MatFormFieldControl, useExisting: MatChipList}],\n  styleUrls: ['chips.css'],\n  encapsulation: ViewEncapsulation.None,\n  preserveWhitespaces: false,\n  changeDetection: ChangeDetectionStrategy.OnPush\n})\nexport class MatChipList extends _MatChipListMixinBase implements MatFormFieldControl<any>,\n    ControlValueAccessor, AfterContentInit, DoCheck, OnInit, OnDestroy, CanUpdateErrorState {\n  readonly controlType = 'mat-chip-list';\n\n  /** When a chip is destroyed, we track the index so we can focus the appropriate next chip. */\n  protected _lastDestroyedIndex: number|null = null;\n\n  /** Track which chips we're listening to for focus/destruction. */\n  protected _chipSet: WeakMap<MatChip, boolean> = new WeakMap();\n\n  /** Subscription to tabbing out from the chip list. */\n  private _tabOutSubscription = Subscription.EMPTY;\n\n  /** Subscription to changes in the chip list. */\n  private _changeSubscription: Subscription;\n\n  /** Subscription to focus changes in the chips. */\n  private _chipFocusSubscription: Subscription|null;\n\n  /** Subscription to blur changes in the chips. */\n  private _chipBlurSubscription: Subscription|null;\n\n  /** Subscription to selection changes in chips. */\n  private _chipSelectionSubscription: Subscription|null;\n\n  /** Subscription to remove changes in chips. */\n  private _chipRemoveSubscription: Subscription|null;\n\n  /** Whether or not the chip is selectable. */\n  protected _selectable: boolean = true;\n\n  /** Whether the component is in multiple selection mode. */\n  private _multiple: boolean = false;\n\n  /** The chip input to add more chips */\n  protected _chipInput: MatChipInput;\n\n  /** Id of the chip list */\n  protected _id: string;\n\n  /** Uid of the chip list */\n  protected _uid: string = `mat-chip-list-${nextUniqueId++}`;\n\n  /** Whether this is required */\n  protected _required: boolean = false;\n\n  /** Whether this is disabled */\n  protected _disabled: boolean = false;\n\n  protected _value: any;\n\n  /** Placeholder for the chip list. Alternatively, placeholder can be set on MatChipInput */\n  protected _placeholder: string;\n\n  /** The aria-describedby attribute on the chip list for improved a11y. */\n  _ariaDescribedby: string;\n\n  /** Tab index for the chip list. */\n  _tabIndex = 0;\n\n  /**\n   * User defined tab index.\n   * When it is not null, use user defined tab index. Otherwise use _tabIndex\n   */\n  _userTabIndex: number | null = null;\n\n  /** The FocusKeyManager which handles focus. */\n  _keyManager: FocusKeyManager<MatChip>;\n\n  /** Function when touched */\n  _onTouched = () => {};\n\n  /** Function when changed */\n  _onChange: (value: any) => void = () => {};\n\n  _selectionModel: SelectionModel<MatChip>;\n\n  /** Comparison function to specify which option is displayed. Defaults to object equality. */\n  private _compareWith = (o1: any, o2: any) => o1 === o2;\n\n  /** The array of selected chips inside chip list. */\n  get selected(): MatChip[] | MatChip {\n    return this.multiple ? this._selectionModel.selected : this._selectionModel.selected[0];\n  }\n\n  get role(): string|null {\n    return this.empty ? null : 'listbox';\n  }\n\n  /** An object used to control when error messages are shown. */\n  @Input() errorStateMatcher: ErrorStateMatcher;\n\n  /** Whether the user should be allowed to select multiple chips. */\n  @Input()\n  get multiple(): boolean { return this._multiple; }\n  set multiple(value: boolean) {\n    this._multiple = coerceBooleanProperty(value);\n  }\n\n  /**\n   * A function to compare the option values with the selected values. The first argument\n   * is a value from an option. The second is a value from the selection. A boolean\n   * should be returned.\n   */\n  @Input()\n  get compareWith() { return this._compareWith; }\n  set compareWith(fn: (o1: any, o2: any) => boolean) {\n    this._compareWith = fn;\n    if (this._selectionModel) {\n      // A different comparator means the selection could change.\n      this._initializeSelection();\n    }\n  }\n\n  /** Required for FormFieldControl */\n  @Input()\n  get value() { return this._value; }\n  set value(newValue: any) {\n    this.writeValue(newValue);\n    this._value = newValue;\n  }\n\n  /** Required for FormFieldControl. The ID of the chip list */\n  @Input()\n  set id(value: string) {\n    this._id = value;\n    this.stateChanges.next();\n  }\n  get id() { return this._id || this._uid; }\n\n  /** Required for FormFieldControl. Whether the chip list is required. */\n  @Input()\n  set required(value: any) {\n    this._required = coerceBooleanProperty(value);\n    this.stateChanges.next();\n  }\n  get required() {\n    return this._required;\n  }\n\n  /** For FormFieldControl. Use chip input's placholder if there's a chip input */\n  @Input()\n  set placeholder(value: string) {\n    this._placeholder = value;\n    this.stateChanges.next();\n  }\n  get placeholder() {\n    return this._chipInput ? this._chipInput.placeholder : this._placeholder;\n  }\n\n  /** Whether any chips or the matChipInput inside of this chip-list has focus. */\n  get focused(): boolean {\n    return this.chips.some(chip => chip._hasFocus) ||\n      (this._chipInput && this._chipInput.focused);\n  }\n\n  /** Whether this chip-list contains no chips and no matChipInput. */\n  get empty(): boolean {\n    return (!this._chipInput || this._chipInput.empty) && this.chips.length === 0;\n  }\n\n  get shouldLabelFloat(): boolean {\n    return !this.empty || this.focused;\n  }\n\n  /** Whether this chip-list is disabled. */\n  @Input()\n  get disabled() { return this.ngControl ? this.ngControl.disabled : this._disabled; }\n  set disabled(value: any) { this._disabled = coerceBooleanProperty(value); }\n\n\n  /** Orientation of the chip list. */\n  @Input('aria-orientation') ariaOrientation: 'horizontal' | 'vertical' = 'horizontal';\n\n  /**\n   * Whether or not this chip is selectable. When a chip is not selectable,\n   * its selected state is always ignored.\n   */\n  @Input()\n  get selectable(): boolean { return this._selectable; }\n  set selectable(value: boolean) { this._selectable = coerceBooleanProperty(value); }\n\n  @Input()\n  set tabIndex(value: number) {\n    this._userTabIndex = value;\n    this._tabIndex = value;\n  }\n\n  /** Combined stream of all of the child chips' selection change events. */\n  get chipSelectionChanges(): Observable<MatChipSelectionChange> {\n    return merge(...this.chips.map(chip => chip.selectionChange));\n  }\n\n  /** Combined stream of all of the child chips' focus change events. */\n  get chipFocusChanges(): Observable<MatChipEvent> {\n    return merge(...this.chips.map(chip => chip._onFocus));\n  }\n\n  /** Combined stream of all of the child chips' blur change events. */\n  get chipBlurChanges(): Observable<MatChipEvent> {\n    return merge(...this.chips.map(chip => chip._onBlur));\n  }\n\n  /** Combined stream of all of the child chips' remove change events. */\n  get chipRemoveChanges(): Observable<MatChipEvent> {\n    return merge(...this.chips.map(chip => chip.destroy));\n  }\n\n  /** Event emitted when the selected chip list value has been changed by the user. */\n  @Output() change: EventEmitter<MatChipListChange> = new EventEmitter<MatChipListChange>();\n\n  /**\n   * Event that emits whenever the raw value of the chip-list changes. This is here primarily\n   * to facilitate the two-way binding for the `value` input.\n   * @docs-private\n   */\n  @Output() valueChange = new EventEmitter<any>();\n\n  /** The chip components contained within this chip list. */\n  @ContentChildren(MatChip) chips: QueryList<MatChip>;\n\n  constructor(protected _elementRef: ElementRef,\n              private _changeDetectorRef: ChangeDetectorRef,\n              @Optional() private _dir: Directionality,\n              @Optional() _parentForm: NgForm,\n              @Optional() _parentFormGroup: FormGroupDirective,\n              _defaultErrorStateMatcher: ErrorStateMatcher,\n              @Optional() @Self() public ngControl: NgControl) {\n    super(_defaultErrorStateMatcher, _parentForm, _parentFormGroup, ngControl);\n    if (this.ngControl) {\n      this.ngControl.valueAccessor = this;\n    }\n  }\n\n  ngAfterContentInit(): void {\n\n    this._keyManager = new FocusKeyManager<MatChip>(this.chips).withWrap();\n\n    // Prevents the chip list from capturing focus and redirecting\n    // it back to the first chip when the user tabs out.\n    this._tabOutSubscription = this._keyManager.tabOut.subscribe(() => {\n      this._tabIndex = -1;\n      setTimeout(() => this._tabIndex = this._userTabIndex || 0);\n    });\n\n    // When the list changes, re-subscribe\n    this._changeSubscription = this.chips.changes.pipe(startWith(null)).subscribe(() => {\n      this._resetChips();\n\n      // Reset chips selected/deselected status\n      this._initializeSelection();\n\n      // Check to see if we need to update our tab index\n      this._updateTabIndex();\n\n      // Check to see if we have a destroyed chip and need to refocus\n      this._updateFocusForDestroyedChips();\n    });\n  }\n\n  ngOnInit() {\n    this._selectionModel = new SelectionModel<MatChip>(this.multiple, undefined, false);\n    this.stateChanges.next();\n  }\n\n  ngDoCheck() {\n    if (this.ngControl) {\n      // We need to re-evaluate this on every change detection cycle, because there are some\n      // error triggers that we can't subscribe to (e.g. parent form submissions). This means\n      // that whatever logic is in here has to be super lean or we risk destroying the performance.\n      this.updateErrorState();\n    }\n  }\n\n  ngOnDestroy(): void {\n    this._tabOutSubscription.unsubscribe();\n\n    if (this._changeSubscription) {\n      this._changeSubscription.unsubscribe();\n    }\n    this._dropSubscriptions();\n    this.stateChanges.complete();\n  }\n\n\n  /** Associates an HTML input element with this chip list. */\n  registerInput(inputElement: MatChipInput) {\n    this._chipInput = inputElement;\n  }\n\n  // Implemented as part of MatFormFieldControl.\n  setDescribedByIds(ids: string[]) { this._ariaDescribedby = ids.join(' '); }\n\n  // Implemented as part of ControlValueAccessor\n  writeValue(value: any): void {\n    if (this.chips) {\n      this._setSelectionByValue(value, false);\n    }\n  }\n\n  // Implemented as part of ControlValueAccessor\n  registerOnChange(fn: (value: any) => void): void {\n    this._onChange = fn;\n  }\n\n  // Implemented as part of ControlValueAccessor\n  registerOnTouched(fn: () => void): void {\n    this._onTouched = fn;\n  }\n\n  // Implemented as part of ControlValueAccessor\n  setDisabledState(disabled: boolean): void {\n    this.disabled = disabled;\n    this._elementRef.nativeElement.disabled = disabled;\n    this.stateChanges.next();\n  }\n\n  onContainerClick() {\n    this.focus();\n  }\n\n  /**\n   * Focuses the the first non-disabled chip in this chip list, or the associated input when there\n   * are no eligible chips.\n   */\n  focus() {\n    // TODO: ARIA says this should focus the first `selected` chip if any are selected.\n    // Focus on first element if there's no chipInput inside chip-list\n    if (this._chipInput && this._chipInput.focused) {\n      // do nothing\n    } else if (this.chips.length > 0) {\n      this._keyManager.setFirstItemActive();\n      this.stateChanges.next();\n    } else {\n      this._focusInput();\n      this.stateChanges.next();\n    }\n  }\n\n  /** Attempt to focus an input if we have one. */\n  _focusInput() {\n    if (this._chipInput) {\n      this._chipInput.focus();\n    }\n  }\n\n  /**\n   * Pass events to the keyboard manager. Available here for tests.\n   */\n  _keydown(event: KeyboardEvent) {\n    let code = event.keyCode;\n    let target = event.target as HTMLElement;\n    let isInputEmpty = this._isInputEmpty(target);\n    let isRtl = this._dir && this._dir.value == 'rtl';\n\n    let isPrevKey = (code === (isRtl ? RIGHT_ARROW : LEFT_ARROW));\n    let isNextKey = (code === (isRtl ? LEFT_ARROW : RIGHT_ARROW));\n    let isBackKey = code === BACKSPACE;\n    // If they are on an empty input and hit backspace, focus the last chip\n    if (isInputEmpty && isBackKey) {\n      this._keyManager.setLastItemActive();\n      event.preventDefault();\n      return;\n    }\n\n    // If they are on a chip, check for space/left/right, otherwise pass to our key manager (like\n    // up/down keys)\n    if (target && target.classList.contains('mat-chip')) {\n      if (isPrevKey) {\n        this._keyManager.setPreviousItemActive();\n        event.preventDefault();\n      } else if (isNextKey) {\n        this._keyManager.setNextItemActive();\n        event.preventDefault();\n      } else {\n        this._keyManager.onKeydown(event);\n      }\n    }\n    this.stateChanges.next();\n  }\n\n\n  /**\n   * Check the tab index as you should not be allowed to focus an empty list.\n   */\n  protected _updateTabIndex(): void {\n    // If we have 0 chips, we should not allow keyboard focus\n    this._tabIndex = this._userTabIndex || (this.chips.length === 0 ? -1 : 0);\n  }\n\n  /**\n   * Update key manager's active item when chip is deleted.\n   * If the deleted chip is the last chip in chip list, focus the new last chip.\n   * Otherwise focus the next chip in the list.\n   * Save `_lastDestroyedIndex` so we can set the correct focus.\n   */\n  protected _updateKeyManager(chip: MatChip) {\n    let chipIndex: number = this.chips.toArray().indexOf(chip);\n    if (this._isValidIndex(chipIndex)) {\n      if (chip._hasFocus) {\n        // Check whether the chip is not the last item\n        if (chipIndex < this.chips.length - 1) {\n          this._keyManager.setActiveItem(chipIndex);\n        } else if (chipIndex - 1 >= 0) {\n          this._keyManager.setActiveItem(chipIndex - 1);\n        }\n      }\n      if (this._keyManager.activeItemIndex === chipIndex) {\n        this._lastDestroyedIndex = chipIndex;\n      }\n    }\n  }\n\n  /**\n   * Checks to see if a focus chip was recently destroyed so that we can refocus the next closest\n   * one.\n   */\n  protected _updateFocusForDestroyedChips() {\n    let chipsArray = this.chips;\n\n    if (this._lastDestroyedIndex != null && chipsArray.length > 0) {\n      // Check whether the destroyed chip was the last item\n      const newFocusIndex = Math.min(this._lastDestroyedIndex, chipsArray.length - 1);\n      this._keyManager.setActiveItem(newFocusIndex);\n      let focusChip = this._keyManager.activeItem;\n      // Focus the chip\n      if (focusChip) {\n        focusChip.focus();\n      }\n    }\n\n    // Reset our destroyed index\n    this._lastDestroyedIndex = null;\n  }\n\n  /**\n   * Utility to ensure all indexes are valid.\n   *\n   * @param index The index to be checked.\n   * @returns True if the index is valid for our list of chips.\n   */\n  private _isValidIndex(index: number): boolean {\n    return index >= 0 && index < this.chips.length;\n  }\n\n  private _isInputEmpty(element: HTMLElement): boolean {\n    if (element && element.nodeName.toLowerCase() === 'input') {\n      let input = element as HTMLInputElement;\n      return !input.value;\n    }\n\n    return false;\n  }\n\n  _setSelectionByValue(value: any, isUserInput: boolean = true) {\n    this._clearSelection();\n    this.chips.forEach(chip => chip.deselect());\n\n    if (Array.isArray(value)) {\n      value.forEach(currentValue => this._selectValue(currentValue, isUserInput));\n      this._sortValues();\n    } else {\n      const correspondingChip = this._selectValue(value, isUserInput);\n\n      // Shift focus to the active item. Note that we shouldn't do this in multiple\n      // mode, because we don't know what chip the user interacted with last.\n      if (correspondingChip) {\n        const correspondingChipIndex = this.chips.toArray().indexOf(correspondingChip);\n\n        if (isUserInput) {\n          this._keyManager.setActiveItem(correspondingChipIndex);\n        } else {\n          this._keyManager.updateActiveItemIndex(correspondingChipIndex);\n        }\n\n      }\n    }\n  }\n\n  /**\n   * Finds and selects the chip based on its value.\n   * @returns Chip that has the corresponding value.\n   */\n  private _selectValue(value: any, isUserInput: boolean = true): MatChip | undefined {\n\n    const correspondingChip = this.chips.find(chip => {\n      return chip.value != null && this._compareWith(chip.value,  value);\n    });\n\n    if (correspondingChip) {\n      isUserInput ? correspondingChip.selectViaInteraction() : correspondingChip.select();\n      this._selectionModel.select(correspondingChip);\n    }\n\n    return correspondingChip;\n  }\n\n  private _initializeSelection(): void {\n    // Defer setting the value in order to avoid the \"Expression\n    // has changed after it was checked\" errors from Angular.\n    Promise.resolve().then(() => {\n      if (this.ngControl || this._value) {\n        this._setSelectionByValue(this.ngControl ? this.ngControl.value : this._value, false);\n        this.stateChanges.next();\n      }\n    });\n  }\n\n  /**\n   * Deselects every chip in the list.\n   * @param skip Chip that should not be deselected.\n   */\n  private _clearSelection(skip?: MatChip): void {\n    this._selectionModel.clear();\n    this.chips.forEach(chip => {\n      if (chip !== skip) {\n        chip.deselect();\n      }\n    });\n    this.stateChanges.next();\n  }\n\n  /**\n   * Sorts the model values, ensuring that they keep the same\n   * order that they have in the panel.\n   */\n  private _sortValues(): void {\n    if (this._multiple) {\n      this._selectionModel.clear();\n\n      this.chips.forEach(chip => {\n        if (chip.selected) {\n          this._selectionModel.select(chip);\n        }\n      });\n      this.stateChanges.next();\n    }\n  }\n\n  /** Emits change event to set the model value. */\n  private _propagateChanges(fallbackValue?: any): void {\n    let valueToEmit: any = null;\n\n    if (Array.isArray(this.selected)) {\n      valueToEmit = this.selected.map(chip => chip.value);\n    } else {\n      valueToEmit = this.selected ? this.selected.value : fallbackValue;\n    }\n    this._value = valueToEmit;\n    this.change.emit(new MatChipListChange(this, valueToEmit));\n    this.valueChange.emit(valueToEmit);\n    this._onChange(valueToEmit);\n    this._changeDetectorRef.markForCheck();\n  }\n\n  /** When blurred, mark the field as touched when focus moved outside the chip list. */\n  _blur() {\n    if (!this.disabled) {\n      if (this._chipInput) {\n        // If there's a chip input, we should check whether the focus moved to chip input.\n        // If the focus is not moved to chip input, mark the field as touched. If the focus moved\n        // to chip input, do nothing.\n        // Timeout is needed to wait for the focus() event trigger on chip input.\n        setTimeout(() => {\n          if (!this.focused) {\n            this._markAsTouched();\n          }\n        });\n      } else {\n        // If there's no chip input, then mark the field as touched.\n        this._markAsTouched();\n      }\n    }\n  }\n\n  /** Mark the field as touched */\n  _markAsTouched() {\n    this._onTouched();\n    this._changeDetectorRef.markForCheck();\n    this.stateChanges.next();\n  }\n\n  private _resetChips() {\n    this._dropSubscriptions();\n    this._listenToChipsFocus();\n    this._listenToChipsSelection();\n    this._listenToChipsRemoved();\n  }\n\n\n  private _dropSubscriptions() {\n    if (this._chipFocusSubscription) {\n      this._chipFocusSubscription.unsubscribe();\n      this._chipFocusSubscription = null;\n    }\n\n    if (this._chipBlurSubscription) {\n      this._chipBlurSubscription.unsubscribe();\n      this._chipBlurSubscription = null;\n    }\n\n    if (this._chipSelectionSubscription) {\n      this._chipSelectionSubscription.unsubscribe();\n      this._chipSelectionSubscription = null;\n    }\n  }\n\n  /** Listens to user-generated selection events on each chip. */\n  private _listenToChipsSelection(): void {\n    this._chipSelectionSubscription = this.chipSelectionChanges.subscribe(event => {\n      event.source.selected\n        ? this._selectionModel.select(event.source)\n        : this._selectionModel.deselect(event.source);\n\n      // For single selection chip list, make sure the deselected value is unselected.\n      if (!this.multiple) {\n        this.chips.forEach(chip => {\n          if (!this._selectionModel.isSelected(chip) && chip.selected) {\n            chip.deselect();\n          }\n        });\n      }\n\n      if (event.isUserInput) {\n        this._propagateChanges();\n      }\n    });\n  }\n\n  /** Listens to user-generated selection events on each chip. */\n  private _listenToChipsFocus(): void {\n    this._chipFocusSubscription = this.chipFocusChanges.subscribe(event => {\n      let chipIndex: number = this.chips.toArray().indexOf(event.chip);\n\n      if (this._isValidIndex(chipIndex)) {\n        this._keyManager.updateActiveItemIndex(chipIndex);\n      }\n      this.stateChanges.next();\n    });\n\n    this._chipBlurSubscription = this.chipBlurChanges.subscribe(_ => {\n      this._blur();\n      this.stateChanges.next();\n    });\n  }\n\n  private _listenToChipsRemoved(): void {\n    this._chipRemoveSubscription = this.chipRemoveChanges.subscribe((event) => {\n      this._updateKeyManager(event.chip);\n    });\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {coerceBooleanProperty} from '@angular/cdk/coercion';\nimport {ENTER} from '@angular/cdk/keycodes';\nimport {Directive, ElementRef, EventEmitter, Input, Output} from '@angular/core';\nimport {MatChipList} from './chip-list';\n\n\n/** Represents an input event on a `matChipInput`. */\nexport interface MatChipInputEvent {\n  /** The native `<input>` element that the event is being fired for. */\n  input: HTMLInputElement;\n\n  /** The value of the input. */\n  value: string;\n}\n\n/**\n * Directive that adds chip-specific behaviors to an input element inside <mat-form-field>.\n * May be placed inside or outside of an <mat-chip-list>.\n */\n@Directive({\n  selector: 'input[matChipInputFor]',\n  exportAs: 'matChipInput, matChipInputFor',\n  host: {\n    'class': 'mat-chip-input mat-input-element',\n    '(keydown)': '_keydown($event)',\n    '(blur)': '_blur()',\n    '(focus)': '_focus()',\n    '(input)': '_onInput()',\n  }\n})\nexport class MatChipInput {\n  focused: boolean = false;\n  _chipList: MatChipList;\n\n  /** Register input for chip list */\n  @Input('matChipInputFor')\n  set chipList(value: MatChipList) {\n    if (value) {\n      this._chipList = value;\n      this._chipList.registerInput(this);\n    }\n  }\n\n  /**\n   * Whether or not the chipEnd event will be emitted when the input is blurred.\n   */\n  @Input('matChipInputAddOnBlur')\n  get addOnBlur() { return this._addOnBlur; }\n  set addOnBlur(value: boolean) { this._addOnBlur = coerceBooleanProperty(value); }\n  _addOnBlur: boolean = false;\n\n  /**\n   * The list of key codes that will trigger a chipEnd event.\n   *\n   * Defaults to `[ENTER]`.\n   */\n  // TODO(tinayuangao): Support Set here\n  @Input('matChipInputSeparatorKeyCodes') separatorKeyCodes: number[] = [ENTER];\n\n  /** Emitted when a chip is to be added. */\n  @Output('matChipInputTokenEnd')\n  chipEnd = new EventEmitter<MatChipInputEvent>();\n\n  /** The input's placeholder text. */\n  @Input() placeholder: string = '';\n\n  /** Whether the input is empty. */\n  get empty(): boolean {\n    let value: string | null = this._inputElement.value;\n    return (value == null || value === '');\n  }\n\n  /** The native input element to which this directive is attached. */\n  protected _inputElement: HTMLInputElement;\n\n  constructor(protected _elementRef: ElementRef) {\n    this._inputElement = this._elementRef.nativeElement as HTMLInputElement;\n  }\n\n  /** Utility method to make host definition/tests more clear. */\n  _keydown(event?: KeyboardEvent) {\n    this._emitChipEnd(event);\n  }\n\n  /** Checks to see if the blur should emit the (chipEnd) event. */\n  _blur() {\n    if (this.addOnBlur) {\n      this._emitChipEnd();\n    }\n    this.focused = false;\n    // Blur the chip list if it is not focused\n    if (!this._chipList.focused) {\n      this._chipList._blur();\n    }\n    this._chipList.stateChanges.next();\n  }\n\n  _focus() {\n    this.focused = true;\n    this._chipList.stateChanges.next();\n  }\n\n  /** Checks to see if the (chipEnd) event needs to be emitted. */\n  _emitChipEnd(event?: KeyboardEvent) {\n    if (!this._inputElement.value && !!event) {\n      this._chipList._keydown(event);\n    }\n    if (!event || this.separatorKeyCodes.indexOf(event.keyCode) > -1) {\n      this.chipEnd.emit({ input: this._inputElement, value: this._inputElement.value });\n\n      if (event) {\n        event.preventDefault();\n      }\n    }\n  }\n\n  _onInput() {\n    // Let chip list know whenever the value changes.\n    this._chipList.stateChanges.next();\n  }\n\n  focus() { this._inputElement.focus(); }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {NgModule} from '@angular/core';\nimport {ErrorStateMatcher} from '@angular/material/core';\nimport {MatChipList} from './chip-list';\nimport {MatBasicChip, MatChip, MatChipRemove} from './chip';\nimport {MatChipInput} from './chip-input';\n\n\n@NgModule({\n  imports: [],\n  exports: [MatChipList, MatChip, MatChipInput, MatChipRemove, MatChipRemove, MatBasicChip],\n  declarations: [MatChipList, MatChip, MatChipInput, MatChipRemove,  MatChipRemove, MatBasicChip],\n  providers: [ErrorStateMatcher]\n})\nexport class MatChipsModule {}\n"],"names":["__extends","d","b","__","this","constructor","extendStatics","prototype","Object","create","setPrototypeOf","__proto__","Array","p","hasOwnProperty","MatChipSelectionChange","source","selected","isUserInput","MatChipBase","_elementRef","_MatChipMixinBase","mixinColor","mixinDisabled","type","Directive","args","selector","host","class","MatBasicChip","MatChip","_this","_super","call","_selected","_selectable","_removable","_hasFocus","_onFocus","Subject","_onBlur","selectionChange","EventEmitter","destroyed","destroy","removed","onRemove","tslib_1.__extends","defineProperty","value","coerceBooleanProperty","emit","undefined","_value","nativeElement","textContent","newValue","selectable","toString","ngOnDestroy","chip","select","deselect","selectViaInteraction","toggleSelected","focus","next","remove","removable","_handleClick","event","disabled","preventDefault","stopPropagation","_handleKeydown","keyCode","DELETE","BACKSPACE","SPACE","_blur","inputs","exportAs","[attr.tabindex]","role","[class.mat-chip-selected]","[attr.disabled]","[attr.aria-disabled]","[attr.aria-selected]","(click)","(keydown)","(focus)","(blur)","ElementRef","Input","Output","MatChipRemove","_parentChip","MatChipListBase","_defaultErrorStateMatcher","_parentForm","_parentFormGroup","ngControl","_MatChipListMixinBase","mixinErrorState","nextUniqueId","MatChipListChange","MatChipList","_changeDetectorRef","_dir","controlType","_lastDestroyedIndex","_chipSet","WeakMap","_tabOutSubscription","Subscription","EMPTY","_multiple","_uid","_required","_disabled","_tabIndex","_userTabIndex","_onTouched","_onChange","_compareWith","o1","o2","ariaOrientation","change","valueChange","valueAccessor","multiple","_selectionModel","empty","fn","_initializeSelection","writeValue","_id","stateChanges","_chipInput","placeholder","_placeholder","chips","some","focused","length","merge","apply","map","ngAfterContentInit","_keyManager","FocusKeyManager","withWrap","tabOut","subscribe","setTimeout","_changeSubscription","changes","pipe","startWith","_resetChips","_updateTabIndex","_updateFocusForDestroyedChips","ngOnInit","SelectionModel","ngDoCheck","updateErrorState","unsubscribe","_dropSubscriptions","complete","registerInput","inputElement","setDescribedByIds","ids","_ariaDescribedby","join","_setSelectionByValue","registerOnChange","registerOnTouched","setDisabledState","onContainerClick","setFirstItemActive","_focusInput","_keydown","code","target","isInputEmpty","_isInputEmpty","isRtl","isPrevKey","RIGHT_ARROW","LEFT_ARROW","isNextKey","isBackKey","setLastItemActive","classList","contains","setPreviousItemActive","setNextItemActive","onKeydown","_updateKeyManager","chipIndex","toArray","indexOf","_isValidIndex","setActiveItem","activeItemIndex","chipsArray","newFocusIndex","Math","min","focusChip","activeItem","index","element","nodeName","toLowerCase","_clearSelection","forEach","isArray","currentValue","_selectValue","_sortValues","correspondingChip","correspondingChipIndex","updateActiveItemIndex","find","Promise","resolve","then","skip","clear","_propagateChanges","fallbackValue","valueToEmit","markForCheck","_markAsTouched","_listenToChipsFocus","_listenToChipsSelection","_listenToChipsRemoved","_chipFocusSubscription","_chipBlurSubscription","_chipSelectionSubscription","chipSelectionChanges","isSelected","chipFocusChanges","chipBlurChanges","_","_chipRemoveSubscription","chipRemoveChanges","Component","template","[attr.aria-describedby]","[attr.aria-required]","[attr.aria-invalid]","[attr.aria-multiselectable]","[attr.role]","[class.mat-chip-list-disabled]","[class.mat-chip-list-invalid]","[class.mat-chip-list-required]","[attr.aria-orientation]","providers","provide","MatFormFieldControl","useExisting","styles","encapsulation","ViewEncapsulation","None","preserveWhitespaces","changeDetection","ChangeDetectionStrategy","OnPush","Directionality","decorators","Optional","NgForm","FormGroupDirective","ErrorStateMatcher","NgControl","Self","propDecorators","compareWith","id","required","tabIndex","ContentChildren","MatChipInput","_addOnBlur","separatorKeyCodes","ENTER","chipEnd","_inputElement","_chipList","_emitChipEnd","addOnBlur","_focus","input","_onInput","(input)","chipList","MatChipsModule","NgModule","imports","exports","declarations"],"mappings":"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"}