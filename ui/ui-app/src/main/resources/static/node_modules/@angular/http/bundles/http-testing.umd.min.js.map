{"version":3,"sources":["http-testing.umd.js"],"names":["global","factory","exports","module","require","define","amd","ng","http","testing","core","Rx","Observable","prototype","this","_angular_core","_angular_http","rxjs_ReplaySubject","rxjs_Subject","rxjs_operator_take","MockConnection","req","response","take","call","ReplaySubject","readyState","ReadyState","Open","request","mockRespond","res","Done","Cancelled","Error","next","complete","mockDownload","mockError","err","error","MockBackend","_this","connectionsArray","connections","Subject","subscribe","connection","push","pendingConnections","verifyNoPendingRequests","pending","c","resolveAllConnections","createConnection","Request","decorators","type","Injectable","ctorParameters","Object","defineProperty","value"],"mappings":";;;;;CAKC,SAAUA,OAAQC,SACC,gBAAZC,UAA0C,mBAAXC,QAAyBF,QAAQC,QAASE,QAAQ,iBAAkBA,QAAQ,iBAAkBA,QAAQ,sBAAuBA,QAAQ,gBAAiBA,QAAQ,uBAClL,kBAAXC,SAAyBA,OAAOC,IAAMD,OAAO,yBAA0B,UAAW,gBAAiB,gBAAiB,qBAAsB,eAAgB,sBAAuBJ,SACvLA,SAASD,OAAOO,GAAKP,OAAOO,OAAUP,OAAOO,GAAGC,KAAOR,OAAOO,GAAGC,SAAYR,OAAOO,GAAGC,KAAKC,YAAcT,OAAOO,GAAGG,KAAKV,OAAOO,GAAGC,KAAKR,OAAOW,GAAGX,OAAOW,GAAGX,OAAOW,GAAGC,WAAWC,YACjLC,KAAM,SAAWZ,QAAQa,cAAcC,cAAcC,mBAAmBC,aAAaC,oBAAsB;;;;;;;;;;;;AAwB7G,GAAIC,gBAAgC,WAChC,QAASA,gBAAeC,KACpBP,KAAKQ,SAA6BH,mBAAmBI,KAAKC,KAAK,GAAIP,oBAAmBQ,cAAc,GAAI,GACxGX,KAAKY,WAAaV,cAAcW,WAAWC,KAC3Cd,KAAKe,QAAUR,IA8InB,MA5GAD,gBAAeP,UAAUiB,YAiBzB,SAAUC,KACN,GAAIjB,KAAKY,aAAeV,cAAcW,WAAWK,MAAQlB,KAAKY,aAAeV,cAAcW,WAAWM,UAClG,KAAM,IAAIC,OAAM,uCAEpBpB,MAAKY,WAAaV,cAAcW,WAAWK,KAC3ClB,KAAKQ,SAASa,KAAKJ,KACnBjB,KAAKQ,SAASc,YAgBlBhB,eAAeP,UAAUwB,aAQzB,SAAUN,OAuCVX,eAAeP,UAAUyB,UAiBzB,SAAUC,KAENzB,KAAKY,WAAaV,cAAcW,WAAWK,KAC3ClB,KAAKQ,SAASkB,MAAMD,MAEjBnB,kBAyFPqB,YAA6B,WAC7B,QAASA,eACL,GAAIC,OAAQ5B,IACZA,MAAK6B,oBACL7B,KAAK8B,YAAc,GAAI1B,cAAa2B,QACpC/B,KAAK8B,YAAYE,UAAU,SAAUC,YAAc,MAAOL,OAAMC,iBAAiBK,KAAKD,cACtFjC,KAAKmC,mBAAqB,GAAI/B,cAAa2B,QAiF/C,MApEAJ,aAAY5B,UAAUqC,wBAMtB,WACI,GAAqBC,SAAU,CAE/B,IADArC,KAAKmC,mBAAmBH,UAAU,SAAUM,GAAK,MAAOD,aACpDA,QAAU,EACV,KAAM,IAAIjB,OAAMiB,QAAU,wCAelCV,YAAY5B,UAAUwC,sBAOtB,WAAcvC,KAAK8B,YAAYE,UAAU,SAAUM,GAAK,MAAOA,GAAE1B,WAAa,KAe9Ee,YAAY5B,UAAUyC,iBAQtB,SAAUjC,KACN,KAAKA,KAASA,cAAeL,eAAcuC,SACvC,KAAM,IAAIrB,OAAM,yDAA2Db,IAE/E,IAAqB0B,YAAa,GAAI3B,gBAAeC,IAErD,OADAP,MAAK8B,YAAYT,KAAKY,YACfA,YAEXN,YAAYe,aACNC,KAAM1C,cAAc2C,aAG1BjB,YAAYkB,eAAiB,WAAc,UACpClB,cAGXvC,SAAQkB,eAAiBA,eACzBlB,QAAQuC,YAAcA,YAEtBmB,OAAOC,eAAe3D,QAAS,cAAgB4D,OAAO","file":"http-testing.umd.min.js","sourcesContent":["/**\n * @license Angular v5.1.3\n * (c) 2010-2017 Google, Inc. https://angular.io/\n * License: MIT\n */\n(function (global, factory) {\n\ttypeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@angular/core'), require('@angular/http'), require('rxjs/ReplaySubject'), require('rxjs/Subject'), require('rxjs/operator/take')) :\n\ttypeof define === 'function' && define.amd ? define('@angular/http/testing', ['exports', '@angular/core', '@angular/http', 'rxjs/ReplaySubject', 'rxjs/Subject', 'rxjs/operator/take'], factory) :\n\t(factory((global.ng = global.ng || {}, global.ng.http = global.ng.http || {}, global.ng.http.testing = {}),global.ng.core,global.ng.http,global.Rx,global.Rx,global.Rx.Observable.prototype));\n}(this, (function (exports,_angular_core,_angular_http,rxjs_ReplaySubject,rxjs_Subject,rxjs_operator_take) { 'use strict';\n\n/**\n * @license Angular v5.1.3\n * (c) 2010-2017 Google, Inc. https://angular.io/\n * License: MIT\n */\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n *\n * Mock Connection to represent a {\\@link Connection} for tests.\n *\n * @deprecated use \\@angular/common/http instead\n */\nvar MockConnection = /** @class */ (function () {\n    function MockConnection(req) {\n        this.response = /** @type {?} */ (rxjs_operator_take.take.call(new rxjs_ReplaySubject.ReplaySubject(1), 1));\n        this.readyState = _angular_http.ReadyState.Open;\n        this.request = req;\n    }\n    /**\n     * Sends a mock response to the connection. This response is the value that is emitted to the\n     * {@link EventEmitter} returned by {@link Http}.\n     *\n     * ### Example\n     *\n     * ```\n     * var connection;\n     * backend.connections.subscribe(c => connection = c);\n     * http.request('data.json').subscribe(res => console.log(res.text()));\n     * connection.mockRespond(new Response(new ResponseOptions({ body: 'fake response' }))); //logs\n     * 'fake response'\n     * ```\n     *\n     */\n    /**\n     * Sends a mock response to the connection. This response is the value that is emitted to the\n     * {\\@link EventEmitter} returned by {\\@link Http}.\n     *\n     * ### Example\n     *\n     * ```\n     * var connection;\n     * backend.connections.subscribe(c => connection = c);\n     * http.request('data.json').subscribe(res => console.log(res.text()));\n     * connection.mockRespond(new Response(new ResponseOptions({ body: 'fake response' }))); //logs\n     * 'fake response'\n     * ```\n     *\n     * @param {?} res\n     * @return {?}\n     */\n    MockConnection.prototype.mockRespond = /**\n     * Sends a mock response to the connection. This response is the value that is emitted to the\n     * {\\@link EventEmitter} returned by {\\@link Http}.\n     *\n     * ### Example\n     *\n     * ```\n     * var connection;\n     * backend.connections.subscribe(c => connection = c);\n     * http.request('data.json').subscribe(res => console.log(res.text()));\n     * connection.mockRespond(new Response(new ResponseOptions({ body: 'fake response' }))); //logs\n     * 'fake response'\n     * ```\n     *\n     * @param {?} res\n     * @return {?}\n     */\n    function (res) {\n        if (this.readyState === _angular_http.ReadyState.Done || this.readyState === _angular_http.ReadyState.Cancelled) {\n            throw new Error('Connection has already been resolved');\n        }\n        this.readyState = _angular_http.ReadyState.Done;\n        this.response.next(res);\n        this.response.complete();\n    };\n    /**\n     * Not yet implemented!\n     *\n     * Sends the provided {@link Response} to the `downloadObserver` of the `Request`\n     * associated with this connection.\n     */\n    /**\n     * Not yet implemented!\n     *\n     * Sends the provided {\\@link Response} to the `downloadObserver` of the `Request`\n     * associated with this connection.\n     * @param {?} res\n     * @return {?}\n     */\n    MockConnection.prototype.mockDownload = /**\n     * Not yet implemented!\n     *\n     * Sends the provided {\\@link Response} to the `downloadObserver` of the `Request`\n     * associated with this connection.\n     * @param {?} res\n     * @return {?}\n     */\n    function (res) {\n        // this.request.downloadObserver.onNext(res);\n        // if (res.bytesLoaded === res.totalBytes) {\n        //   this.request.downloadObserver.onCompleted();\n        // }\n    };\n    // TODO(jeffbcross): consider using Response type\n    /**\n     * Emits the provided error object as an error to the {@link Response} {@link EventEmitter}\n     * returned\n     * from {@link Http}.\n     *\n     * ### Example\n     *\n     * ```\n     * var connection;\n     * backend.connections.subscribe(c => connection = c);\n     * http.request('data.json').subscribe(res => res, err => console.log(err)));\n     * connection.mockError(new Error('error'));\n     * ```\n     *\n     */\n    /**\n     * Emits the provided error object as an error to the {\\@link Response} {\\@link EventEmitter}\n     * returned\n     * from {\\@link Http}.\n     *\n     * ### Example\n     *\n     * ```\n     * var connection;\n     * backend.connections.subscribe(c => connection = c);\n     * http.request('data.json').subscribe(res => res, err => console.log(err)));\n     * connection.mockError(new Error('error'));\n     * ```\n     *\n     * @param {?=} err\n     * @return {?}\n     */\n    MockConnection.prototype.mockError = /**\n     * Emits the provided error object as an error to the {\\@link Response} {\\@link EventEmitter}\n     * returned\n     * from {\\@link Http}.\n     *\n     * ### Example\n     *\n     * ```\n     * var connection;\n     * backend.connections.subscribe(c => connection = c);\n     * http.request('data.json').subscribe(res => res, err => console.log(err)));\n     * connection.mockError(new Error('error'));\n     * ```\n     *\n     * @param {?=} err\n     * @return {?}\n     */\n    function (err) {\n        // Matches ResourceLoader semantics\n        this.readyState = _angular_http.ReadyState.Done;\n        this.response.error(err);\n    };\n    return MockConnection;\n}());\n/**\n * A mock backend for testing the {\\@link Http} service.\n *\n * This class can be injected in tests, and should be used to override providers\n * to other backends, such as {\\@link XHRBackend}.\n *\n * ### Example\n *\n * ```\n * import {Injectable, Injector} from '\\@angular/core';\n * import {async, fakeAsync, tick} from '\\@angular/core/testing';\n * import {BaseRequestOptions, ConnectionBackend, Http, RequestOptions} from '\\@angular/http';\n * import {Response, ResponseOptions} from '\\@angular/http';\n * import {MockBackend, MockConnection} from '\\@angular/http/testing';\n *\n * const HERO_ONE = 'HeroNrOne';\n * const HERO_TWO = 'WillBeAlwaysTheSecond';\n *\n * \\@Injectable()\n * class HeroService {\n *   constructor(private http: Http) {}\n *\n *   getHeroes(): Promise<String[]> {\n *     return this.http.get('myservices.de/api/heroes')\n *         .toPromise()\n *         .then(response => response.json().data)\n *         .catch(e => this.handleError(e));\n *   }\n *\n *   private handleError(error: any): Promise<any> {\n *     console.error('An error occurred', error);\n *     return Promise.reject(error.message || error);\n *   }\n * }\n *\n * describe('MockBackend HeroService Example', () => {\n *   beforeEach(() => {\n *     this.injector = Injector.create([\n *       {provide: ConnectionBackend, useClass: MockBackend},\n *       {provide: RequestOptions, useClass: BaseRequestOptions},\n *       Http,\n *       HeroService,\n *     ]);\n *     this.heroService = this.injector.get(HeroService);\n *     this.backend = this.injector.get(ConnectionBackend) as MockBackend;\n *     this.backend.connections.subscribe((connection: any) => this.lastConnection = connection);\n *   });\n *\n *   it('getHeroes() should query current service url', () => {\n *     this.heroService.getHeroes();\n *     expect(this.lastConnection).toBeDefined('no http service connection at all?');\n *     expect(this.lastConnection.request.url).toMatch(/api\\/heroes$/, 'url invalid');\n *   });\n *\n *   it('getHeroes() should return some heroes', fakeAsync(() => {\n *        let result: String[];\n *        this.heroService.getHeroes().then((heroes: String[]) => result = heroes);\n *        this.lastConnection.mockRespond(new Response(new ResponseOptions({\n *          body: JSON.stringify({data: [HERO_ONE, HERO_TWO]}),\n *        })));\n *        tick();\n *        expect(result.length).toEqual(2, 'should contain given amount of heroes');\n *        expect(result[0]).toEqual(HERO_ONE, ' HERO_ONE should be the first hero');\n *        expect(result[1]).toEqual(HERO_TWO, ' HERO_TWO should be the second hero');\n *      }));\n *\n *   it('getHeroes() while server is down', fakeAsync(() => {\n *        let result: String[];\n *        let catchedError: any;\n *        this.heroService.getHeroes()\n *            .then((heroes: String[]) => result = heroes)\n *            .catch((error: any) => catchedError = error);\n *        this.lastConnection.mockRespond(new Response(new ResponseOptions({\n *          status: 404,\n *          statusText: 'URL not Found',\n *        })));\n *        tick();\n *        expect(result).toBeUndefined();\n *        expect(catchedError).toBeDefined();\n *      }));\n * });\n * ```\n *\n * This method only exists in the mock implementation, not in real Backends.\n *\n * @deprecated use \\@angular/common/http instead\n */\nvar MockBackend = /** @class */ (function () {\n    function MockBackend() {\n        var _this = this;\n        this.connectionsArray = [];\n        this.connections = new rxjs_Subject.Subject();\n        this.connections.subscribe(function (connection) { return _this.connectionsArray.push(connection); });\n        this.pendingConnections = new rxjs_Subject.Subject();\n    }\n    /**\n     * Checks all connections, and raises an exception if any connection has not received a response.\n     *\n     * This method only exists in the mock implementation, not in real Backends.\n     */\n    /**\n     * Checks all connections, and raises an exception if any connection has not received a response.\n     *\n     * This method only exists in the mock implementation, not in real Backends.\n     * @return {?}\n     */\n    MockBackend.prototype.verifyNoPendingRequests = /**\n     * Checks all connections, and raises an exception if any connection has not received a response.\n     *\n     * This method only exists in the mock implementation, not in real Backends.\n     * @return {?}\n     */\n    function () {\n        var /** @type {?} */ pending = 0;\n        this.pendingConnections.subscribe(function (c) { return pending++; });\n        if (pending > 0)\n            throw new Error(pending + \" pending connections to be resolved\");\n    };\n    /**\n     * Can be used in conjunction with `verifyNoPendingRequests` to resolve any not-yet-resolve\n     * connections, if it's expected that there are connections that have not yet received a response.\n     *\n     * This method only exists in the mock implementation, not in real Backends.\n     */\n    /**\n     * Can be used in conjunction with `verifyNoPendingRequests` to resolve any not-yet-resolve\n     * connections, if it's expected that there are connections that have not yet received a response.\n     *\n     * This method only exists in the mock implementation, not in real Backends.\n     * @return {?}\n     */\n    MockBackend.prototype.resolveAllConnections = /**\n     * Can be used in conjunction with `verifyNoPendingRequests` to resolve any not-yet-resolve\n     * connections, if it's expected that there are connections that have not yet received a response.\n     *\n     * This method only exists in the mock implementation, not in real Backends.\n     * @return {?}\n     */\n    function () { this.connections.subscribe(function (c) { return c.readyState = 4; }); };\n    /**\n     * Creates a new {@link MockConnection}. This is equivalent to calling `new\n     * MockConnection()`, except that it also will emit the new `Connection` to the `connections`\n     * emitter of this `MockBackend` instance. This method will usually only be used by tests\n     * against the framework itself, not by end-users.\n     */\n    /**\n     * Creates a new {\\@link MockConnection}. This is equivalent to calling `new\n     * MockConnection()`, except that it also will emit the new `Connection` to the `connections`\n     * emitter of this `MockBackend` instance. This method will usually only be used by tests\n     * against the framework itself, not by end-users.\n     * @param {?} req\n     * @return {?}\n     */\n    MockBackend.prototype.createConnection = /**\n     * Creates a new {\\@link MockConnection}. This is equivalent to calling `new\n     * MockConnection()`, except that it also will emit the new `Connection` to the `connections`\n     * emitter of this `MockBackend` instance. This method will usually only be used by tests\n     * against the framework itself, not by end-users.\n     * @param {?} req\n     * @return {?}\n     */\n    function (req) {\n        if (!req || !(req instanceof _angular_http.Request)) {\n            throw new Error(\"createConnection requires an instance of Request, got \" + req);\n        }\n        var /** @type {?} */ connection = new MockConnection(req);\n        this.connections.next(connection);\n        return connection;\n    };\n    MockBackend.decorators = [\n        { type: _angular_core.Injectable },\n    ];\n    /** @nocollapse */\n    MockBackend.ctorParameters = function () { return []; };\n    return MockBackend;\n}());\n\nexports.MockConnection = MockConnection;\nexports.MockBackend = MockBackend;\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\n})));\n//# sourceMappingURL=http-testing.umd.js.map\n"]}